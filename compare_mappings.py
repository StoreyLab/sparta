# -*- coding: utf-8 -*-
'''
Created on Mon Jun 16 10:56:22 2014

@author: Peter Edge
adapted from compare_mappings() in Emily Nelson's script snp_pipeline.py

usage from command line:
python2 compare_mappings.py <samfile1> <samfile2>
-'''

desc = '''
This file contains the function compare_mappings(), which takes in two SAM
alignment files which map the same RNAseq reads to two different parental
genomes. The RNAseq reads should map to either one parental allele type or the
other. This program sorts the reads as originating from one parental allele
type or the other.
'''

import pysam, argparse, math, re
import pdb

# parse program input.
def parseargs():
    
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('samfile1', nargs='?', type = str, help='path to samfile 1')
    parser.add_argument('samfile2', nargs='?', type = str, help='path to samfile 2')
    parser.add_argument('genome1_name', nargs='?', type = str, help='name for genome 1 (reference for samfile 1)')
    parser.add_argument('genome2_name', nargs='?', type = str, help='name for genome 2 (reference for samfile 2)') 
    args = parser.parse_args()
    return args

# sorter class that sorts an RNAseq read to one parental allele or the other
class multimapped_read_sorter():
    '''
    The following methods compute the probabilities that matched and mismatched bases contribute.
    Let M be the probability of a miscalled base, computed as:
        10^((number specified by phred char)/-10)
        NOTE: the ascii phred char is offset by 33 for sanger format reads
    A matched base contributes (1 - M): the probability that the base call was correct
    and the genome in question generated the observed base.
    A mismatched base contributes M / 3: the probability that the base call was wrong
    and the called base was the observed 1 of 3 possible other bases.
    '''

    MD_REGEX = re.compile("([0-9]+)([A-Z]|\^[A-Z]+)") 

    # dicts that hold precomputed matched base probabilities
    log10_matched_base_probs = {}
    log10_mismatched_base_probs = {}
    
    # given a phred score and assuming an RNA/genome base match, compute the probability
    # that the genome generated the RNA base (probability of correctly called base)
    def log10_matched_base_prob(self, phred_char):
        if phred_char not in self.log10_matched_base_probs:
            self.log10_matched_base_probs[phred_char] = math.log10(1.0 - math.pow(10, (ord(phred_char) - 33) * -0.1))
        return self.log10_matched_base_probs[phred_char]
    
    # given a phred score and assuming an RNA/genome base mismatch, compute the probability that the
    # genome generated the RNA base (probability that the mismatched base was called by the sequencer)
    def log10_mismatched_base_prob(self, phred_char):
        if phred_char not in self.log10_mismatched_base_probs:
            self.log10_mismatched_base_probs[phred_char] = ((ord(phred_char) - 33) * -0.1) - math.log10(3.0)
        return self.log10_mismatched_base_probs[phred_char]

    
    # compute probability of a whole RNAseq read being generated by a genome, 
    # given a pysam aligned_read object of the alignment
    def aligned_read_prob(self, aligned_read):
        
        # the MD string for a SAM object contains the mismatches to the reference  
        # 10C14AA40^T = 10 matched bases, then an unexpected C, then 14 matched
        # bases, then AA where two other bases were expected, then 40 matches, then a deleted T

        err = re.findall(self.MD_REGEX, aligned_read.opt("MD"))
        qual = aligned_read.qual
        return self.err_qual_prob(err, qual)

    # compute probability of a whole RNAseq read being generated by a genome,
    # given a list of (error, offset from last error) tuples and a quality score string
    def err_qual_prob(self, err, qual):
        total = 0
        seq_ix = 0
        # step through sequence
        while err:
            
            matched_bases, curr_err = err.pop()
            # step through the matched bases and sum log10 probabilities that the base was called correctly
            for match in range(0, int(matched_bases)):
                total += self.log10_matched_base_prob(qual[seq_ix])
                seq_ix += 1
            # if there is a deletion, skip forward to after the deletion
            if '^' in curr_err:
                #this is where we should handle deletions                
                pass
            # step through mismatched bases and sum log10 probabilities of that mismatch occuring
            else:
                for mismatched_base in curr_err:
                    total += self.log10_mismatched_base_prob(qual[seq_ix])                
                    seq_ix += 1
        
        # step through the remaining matched bases
        while seq_ix < len(qual):
            total += self.log10_matched_base_prob(qual[seq_ix])
            seq_ix += 1
            
        # sum the probabilities and convert back from log10 scale
        return pow(10, total)

# main program logic; sort RNAseq reads as belonging to one parental allele or the other
def compare_mappings(samfile1, samfile2, genome1_name, genome2_name, genome1_prior=0.5, posterior_cutoff = 0.9):
    
    sorter = multimapped_read_sorter()
    genome2_prior = 1 - genome1_prior   
    
    # samfile objects created from samfile1 and samfile2
    sam1 = pysam.Samfile(samfile1)
    sam2 = pysam.Samfile(samfile2)
    
    no_match    = 0
    match1      = 0
    same_errors = 0
    match_genome1_after_analysis = 0
    match_genome2_after_analysis = 0
    no_match_after_analysis      = 0    
    
    for aligned1, aligned2 in zip(sam1, sam2):
        
        assert aligned1.qname == aligned2.qname     
        
        if aligned1.is_unmapped and aligned2.is_unmapped:
            #this read is probably junk
            no_match += 1
            continue
        elif aligned1.is_unmapped != aligned2.is_unmapped:
            #maps to one but not the other; either junk or
            #an unshared gene bw BY and RM
            match1 += 1
            continue
        elif aligned1.opt("MD") == aligned2.opt("MD"):
            # same errors
            same_errors += 1
        else:
            # bowtie matched the read to both genomes
            prob_read_genome1 = sorter.aligned_read_prob(aligned1)
            prob_read_genome2 = sorter.aligned_read_prob(aligned2)
            
            # apply baiyes rule: compute probability that each genome generated the read
            prob_genome1 = (prob_read_genome1 * genome1_prior /
                            (prob_read_genome1 * genome1_prior + prob_read_genome2 * genome2_prior))
                            
            prob_genome2 = 1.0 - prob_genome1
            
            if (prob_genome1 >= posterior_cutoff):
                print '{}\t{}'.format(aligned1.qname, genome1_name)
                match_genome1_after_analysis += 1
            elif (prob_genome2 >= posterior_cutoff):
                print '{}\t{}'.format(aligned1.qname, genome2_name)
                match_genome2_after_analysis += 1
            else:
                print '{}\tunmapped'.format(aligned1.qname)
                no_match_after_analysis += 1

    print '\n{}\tunmapped by bowtie to either {} or {}'.format(no_match, genome1_name, genome2_name)
    print '{}\tmapped by bowtie to either {} or {}'.format(match1, genome1_name, genome2_name)
    print '{}\tmapped by bowtie to both {} or {}, but errors are same'.format(same_errors, genome1_name, genome2_name)
    #note: but I didn't look for dips in quality scores...?
    total_mapped_to_both = match_genome1_after_analysis + match_genome2_after_analysis + no_match_after_analysis
    print '{}\tmapped by bowtie to both {} and {}:'.format(total_mapped_to_both, genome1_name, genome2_name)    
    print '   {}\tassigned to {} based on errors'.format(match_genome1_after_analysis, genome1_name)
    print '   {}\tassigned to {} based on errors'.format(match_genome2_after_analysis, genome2_name)
    print '   {}\tunmapped based on errors'.format(no_match_after_analysis)

# call compare_mappings() on samfile1 and samfile2 from standard input 
def main():
    args = parseargs()
    samfile1 = args.samfile1
    samfile2 = args.samfile2
    genome1_name = args.genome1_name
    genome2_name = args.genome2_name
    compare_mappings(samfile1, samfile2, genome1_name, genome2_name)

if __name__ == '__main__':
    main()